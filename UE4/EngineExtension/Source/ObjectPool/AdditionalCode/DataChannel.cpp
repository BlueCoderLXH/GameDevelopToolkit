#INCLUDE "REUSABLE.H"

EXTERN OBJECTPOOL_API TAUTOCONSOLEVARIABLE<BOOL> CVARENABLEOBJECTPOOL;

INT64 UACTORCHANNEL::CLOSE(ECHANNELCLOSEREASON REASON)
{
	FSCOPEDREPCONTEXT REPCONTEXT(CONNECTION, ACTOR);

	UE_LOG(LOGNETTRAFFIC, LOG, TEXT("UACTORCHANNEL::CLOSE: CHINDEX: %D, ACTOR: %S, REASON: %S"), CHINDEX, *GETFULLNAMESAFE(ACTOR), LEXTOSTRING(REASON));
	INT64 NUMBITS = UCHANNEL::CLOSE(REASON);

	IF (ACTOR != NULLPTR)
	{
		BOOL BKEEPREPLICATORS = FALSE;		// IF WE KEEP REPLICATORS AROUND, WE CAN USE THEM TO DETERMINE IF THE ACTOR CHANGED SINCE IT WENT DORMANT

		IF (CONNECTION)
		{
			IF (REASON == ECHANNELCLOSEREASON::DORMANCY)
			{
				CONST BOOL BISDRIVERVALID = CONNECTION->DRIVER != NULLPTR;
				CONST BOOL BISSERVER = BISDRIVERVALID && CONNECTION->DRIVER->ISSERVER();
				IF (BISDRIVERVALID)
				{
					IF (!BISSERVER)
					{
						ACTOR->NETDORMANCY = DORM_DORMANTALL;
					}

					CHECK( ACTOR->NETDORMANCY > DORM_AWAKE ); // DORMANCY SHOULD HAVE BEEN CANCELED IF GAME CODE CHANGED NETDORMANCY
					CONNECTION->DRIVER->NOTIFYACTORFULLYDORMANTFORCONNECTION(ACTOR, CONNECTION);
				}

				// VALIDATION CHECKING
				// WE NEED TO KEEP THE REPLICATORS AROUND SO WE CAN REUSE THEM.
				BKEEPREPLICATORS = (GNETDORMANCYVALIDATE > 0) || (BISSERVER && GBNETREUSEREPLICATORSFORDORMANTOBJECTS);
			}
			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL START
			ELSE IF (REASON == ECHANNELCLOSEREASON::RELEVANCY)
			{
				CONST BOOL BISDRIVERVALID = CONNECTION->DRIVER != NULLPTR;
				CONST BOOL BISSERVER = BISDRIVERVALID && CONNECTION->DRIVER->ISSERVER();

				// RESET OBJECT-POOLED ACTOR'S REP-COMPONENTS' GUID ACK STATUS ON SERVER SIDE (BY LXH)
				//
				// ON CLIENT SIDE, GUIDCACHE FOR OBJECT-POOLED ACTOR'S REP-COMPONENTS HAS BEEN REMOVED WHEN THIS ACTOR IS DESTROYED(CHANNELCLOSEREASON:RELEVANCY)
				// WHEN THIS ACTOR COMING TO BE ACTIVE, DS WON'T REPLICATE REP-COMPONENTS' NET GUID FOR IT HAS BEEN ACKED, SO THAT CLIENT WON'T KNOW WHAT OBJECT IT IS.
				// IT WILL LEAD TO SOME NETWORK PROBLEM SUCH AS FAILING TO CALL RPC / REPLICATING PROPERTIES... 
				// TO SOLVE THIS PROBLEM, WE HAVE TO RESET OBJECT-POOLED ACTOR'S REP-COMPONENTS' GUID ACK STATUS HERE.
				BOOL BSHOULDHANDLEFOROBJECTPOOL = FALSE;
				IF (ISVALID(ACTOR) && ISVALID(ACTOR->GETCLASS()) && ACTOR->IMPLEMENTS<UREUSABLE>())
				{
					IF (CONST IREUSABLE* DEFAULTREUSABLEACTOR = CAST<IREUSABLE>(ACTOR->GETCLASS()->GETDEFAULTOBJECT()))
					{
						BSHOULDHANDLEFOROBJECTPOOL = DEFAULTREUSABLEACTOR->SHOULDUSEOBJECTPOOL();
					}
				}
				
				CONST TSHAREDPTR<FNETGUIDCACHE>& GUIDCACHE = BISSERVER ? CONNECTION->DRIVER->GUIDCACHE : NULLPTR;
				IF (BISSERVER && CVARENABLEOBJECTPOOL.GETVALUEONGAMETHREAD() && BSHOULDHANDLEFOROBJECTPOOL && GUIDCACHE.ISVALID())
				{
					CONST TARRAY<UACTORCOMPONENT*>& REPCOMPS = ACTOR->GETREPLICATEDCOMPONENTS();
					FOR (UACTORCOMPONENT* REPCOMP : REPCOMPS)
					{
						IF (!ISVALID(REPCOMP)) CONTINUE;
						
						CONST UPACKAGEMAPCLIENT* PACKAGEMAPCLIENT = CONNECTION ? CAST<UPACKAGEMAPCLIENT>( CONNECTION->PACKAGEMAP ) : NULLPTR;
						IF (PACKAGEMAPCLIENT)
						{
							PACKAGEMAPCLIENT->RESETGUIDACKSTATUS(REPCOMP);
						}
					}
				}
			}
			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL END

			// SETCLOSINGFLAG() MIGHT HAVE ALREADY DONE THIS, BUT WE NEED TO MAKE SURE AS THAT WON'T GET CALLED IF THE CONNECTION ITSELF HAS ALREADY BEEN CLOSED
			CONNECTION->REMOVEACTORCHANNEL( ACTOR );
		}

		ACTOR = NULLPTR;
		CLEANUPREPLICATORS( BKEEPREPLICATORS );
	}

	RETURN NUMBITS;
}

BOOL UACTORCHANNEL::CLEANUP(CONST BOOL BFORDESTROY, ECHANNELCLOSEREASON CLOSEREASON)
{
	SCOPE_CYCLE_COUNTER(STAT_ACTORCHANCLEANUP);

	CHECKF(CONNECTION != NULLPTR, TEXT("UACTORCHANNEL::CLEANUP: CONNECTION IS NULL!"));
	CHECKF(CONNECTION->DRIVER != NULLPTR, TEXT("UACTORCHANNEL::CLEANUP: CONNECTION->DRIVER IS NULL!"));

	CONNECTION->DRIVER->NOTIFYACTORCHANNELCLEANEDUP(THIS, CLOSEREASON);

	CONST BOOL BISSERVER = CONNECTION->DRIVER->ISSERVER();

	UE_LOG( LOGNETTRAFFIC, LOG, TEXT( "UACTORCHANNEL::CLEANUP: %S" ), *DESCRIBE() );
	
	// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL START
	IF (!BISSERVER && CVARENABLEOBJECTPOOL.GETVALUEONGAMETHREAD())
	{
		BOOL BSHOULDHANDLEFOROBJECTPOOL = FALSE;
		IF (ISVALID(ACTOR) && ISVALID(ACTOR->GETCLASS()) && ACTOR->IMPLEMENTS<UREUSABLE>())
		{
			IF (CONST IREUSABLE* DEFAULTREUSABLEACTOR = CAST<IREUSABLE>(ACTOR->GETCLASS()->GETDEFAULTOBJECT()))
			{
				BSHOULDHANDLEFOROBJECTPOOL = DEFAULTREUSABLEACTOR->SHOULDUSEOBJECTPOOL();
			}
		}
		
		// REMOVE OBJECT-POOLED ACTOR FROM GLOBAL CACHE ON CLIENT SIDE (BY LXH)
		//
		// THE OBJECT-POOLED ACTOR AND ITS REPLICATED COMPONENTS MUST BE REMOVED FROM 'OBJECTLOOKUP' AND 'NETGUIDLOOKUP' IN GUIDCACHE
		// TO ENSURE THE EXACT OBJECT POOL FLOW FOR ACTORS(SPAWNACTOR AND DESTROYACTOR).
		IF (BSHOULDHANDLEFOROBJECTPOOL)
		{
			FNETGUIDCACHE* GUIDCACHE = CONNECTION->DRIVER->GUIDCACHE.GET();
			CONST FNETWORKGUID* OBJNETGUID = GUIDCACHE->NETGUIDLOOKUP.FIND(ACTOR);
			IF (OBJNETGUID)
			{
				GUIDCACHE->NETGUIDLOOKUP.REMOVE(ACTOR);
				GUIDCACHE->OBJECTLOOKUP.REMOVE(*OBJNETGUID);
			}

			CONST TARRAY<UACTORCOMPONENT*>& REPCOMPS = ACTOR->GETREPLICATEDCOMPONENTS();
			FOR (UACTORCOMPONENT* REPCOMP : REPCOMPS)
			{
				CONST FNETWORKGUID* REPCOMPNETGUID = GUIDCACHE->NETGUIDLOOKUP.FIND(REPCOMP);
				IF (REPCOMPNETGUID)
				{
					GUIDCACHE->NETGUIDLOOKUP.REMOVE(REPCOMP);
					GUIDCACHE->OBJECTLOOKUP.REMOVE(*REPCOMPNETGUID);
				}
			}
		}
	}
	// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL END

	IF (!BISSERVER && QUEUEDBUNCHES.NUM() > 0 && CHINDEX >= 0 && !BFORDESTROY)
	{
		CHECKF(ACTORNETGUID.ISVALID(), TEXT("UACTORCHANNEL::CLEANUP: ACTORNETGUID IS INVALID! CHANNEL: %I"), CHINDEX);
		
		TARRAY<UACTORCHANNEL*>& CHANNELSSTILLPROCESSING = CONNECTION->KEEPPROCESSINGACTORCHANNELBUNCHESMAP.FINDORADD(ACTORNETGUID);
		
#IF DO_CHECK
		IF (ENSUREMSGF(!CHANNELSSTILLPROCESSING.CONTAINS(THIS), TEXT("UACTORCHANNEL::CLEANUP ENCOUNTERED A CHANNEL ALREADY WITHIN THE KEEPPROCESSINGACTORCHANNELBUNCHMAP. CHANNEL: %I"), CHINDEX))
#ENDIF // #IF DO_CHECK
		{
			UE_LOG(LOGNET, VERYVERBOSE, TEXT("UACTORCHANNEL::CLEANUP: ADDING TO KEEPPROCESSINGACTORCHANNELBUNCHESMAP. CHANNEL: %I, NUM: %I"), CHINDEX, CONNECTION->KEEPPROCESSINGACTORCHANNELBUNCHESMAP.NUM());

			// REMEMBER THE CONNECTION, SINCE CLEANUP BELOW WILL NULL IT
			UNETCONNECTION* OLDCONNECTION = CONNECTION;

			// THIS WILL UNREGISTER THE CHANNEL, AND MAKE IT FREE FOR OPENING AGAIN
			// WE NEED TO DO THIS, SINCE THE SERVER WILL ASSUME THIS CHANNEL IS FREE ONCE WE ACK THIS PACKET
			SUPER::CLEANUP(BFORDESTROY, CLOSEREASON);

			// RESTORE CONNECTION PROPERTY SINCE WE'LL NEED IT FOR PROCESSING BUNCHES (THE SUPER::CLEANUP CALL ABOVE NULL'D IT)
			CONNECTION = OLDCONNECTION;

			QUEUEDCLOSEREASON = CLOSEREASON;

			// ADD THIS CHANNEL TO THE KEEPPROCESSINGACTORCHANNELBUNCHESMAP LIST
			CHANNELSSTILLPROCESSING.ADD(THIS);

			// WE SET CHINDEX TO -1 TO SIGNIFY THAT WE'VE ALREADY BEEN "CLOSED" BUT WE AREN'T DONE PROCESSING BUNCHES
			CHINDEX = -1;

			// RETURN FALSE SO WE WON'T DO PENDING KILL YET
			RETURN FALSE;
		}
	}

	BOOL BWASDORMANT = FALSE;

	// IF WE'RE THE CLIENT, DESTROY THIS ACTOR.
	IF (!BISSERVER)
	{
		CHECK(ACTOR == NULL || ACTOR->ISVALIDLOWLEVEL());
		CHECKSLOW(CONNECTION->ISVALIDLOWLEVEL());
		CHECKSLOW(CONNECTION->DRIVER->ISVALIDLOWLEVEL());
		IF (ACTOR != NULL)
		{
			IF (ACTOR->GETTEAROFF() && !CONNECTION->DRIVER->SHOULDCLIENTDESTROYTEAROFFACTORS())
			{
				IF (!BTORNOFF)
				{
					ACTOR->SETROLE(ROLE_AUTHORITY);
					ACTOR->SETREPLICATES(FALSE);
					BTORNOFF = TRUE;
					IF (ACTOR->GETWORLD() != NULL && !ISENGINEEXITREQUESTED())
					{
						ACTOR->TORNOFF();
					}

					CONNECTION->DRIVER->NOTIFYACTORTORNOFF(ACTOR);
				}
			}
			ELSE IF (DORMANT && (CLOSEREASON == ECHANNELCLOSEREASON::DORMANCY) && !ACTOR->GETTEAROFF())	
			{
				ACTOR->NETDORMANCY = DORM_DORMANTALL;

				CONNECTION->DRIVER->NOTIFYACTORFULLYDORMANTFORCONNECTION(ACTOR, CONNECTION);
				BWASDORMANT = TRUE;
			}
			ELSE IF (!ACTOR->BNETTEMPORARY && ACTOR->GETWORLD() != NULL && !ISENGINEEXITREQUESTED() && CONNECTION->DRIVER->SHOULDCLIENTDESTROYACTOR(ACTOR))
			{
				UE_LOG(LOGNETDORMANCY, VERBOSE, TEXT("UACTORCHANNEL::CLEANUP: DESTROYING ACTOR. %S"), *DESCRIBE() );

				DESTROYACTORANDCOMPONENTS();
			}
		}
	}

	// REMOVE FROM HASH AND STUFF.
	SETCLOSINGFLAG();

	// IF THIS ACTOR IS GOING DORMANT (AND WE ARE A CLIENT), KEEP THE REPLICATORS AROUND, WE NEED THEM TO RUN THE BUSINESS LOGIC FOR UPDATING UNMAPPED PROPERTIES
	CONST BOOL BKEEPREPLICATORS = !BFORDESTROY && BWASDORMANT && (!BISSERVER || GBNETREUSEREPLICATORSFORDORMANTOBJECTS);

	CLEANUPREPLICATORS( BKEEPREPLICATORS );

	// WE DON'T CARE ABOUT ANY LEFTOVER PENDING GUIDS AT THIS POINT
	PENDINGGUIDRESOLVES.EMPTY();
	QUEUEDBUNCHOBJECTREFERENCES.EMPTY();

	// FREE EXPORT BUNCHES LIST
	FOR (FOUTBUNCH* QUEUEDOUTBUNCH : QUEUEDEXPORTBUNCHES)
	{
		DELETE QUEUEDOUTBUNCH;
	}

	QUEUEDEXPORTBUNCHES.EMPTY();

	// FREE THE MUST BE MAPPED LIST
	QUEUEDMUSTBEMAPPEDGUIDSINLASTBUNCH.EMPTY();

	IF (QUEUEDBUNCHES.NUM() > 0)
	{
		// FREE ANY QUEUED BUNCHES
		FOR (FINBUNCH* QUEUEDINBUNCH : QUEUEDBUNCHES)
		{
			DELETE QUEUEDINBUNCH;
		}

		QUEUEDBUNCHES.EMPTY();

		IF (UPACKAGEMAPCLIENT* PACKAGEMAPCLIENT = CAST<UPACKAGEMAPCLIENT>(CONNECTION->PACKAGEMAP))
		{
			PACKAGEMAPCLIENT->SETHASQUEUEDBUNCHES(ACTORNETGUID, FALSE);
		}
	}

	// WE CHECK FOR -1 HERE, WHICH WILL BE TRUE IF THIS CHANNEL HAS ALREADY BEEN CLOSED BUT STILL NEEDED TO PROCESS BUNCHES BEFORE FULLY CLOSING
	IF (CHINDEX >= 0)	
	{
		RETURN SUPER::CLEANUP(BFORDESTROY, CLOSEREASON);
	}
	ELSE
	{
		// BECAUSE WE SET CONNECTION = OLDCONNECTION; ABOVE WHEN WE SET CHINDEX TO -1, WE HAVE TO NULL IT HERE EXPLICITLY TO MAKE SURE THE CONNECTION IS CLEARED BY THE TIME WE LEAVE CLEANUP
		CONNECTION = NULLPTR;
	}

	RETURN TRUE;
}