#INCLUDE "REUSABLE.H"

EXTERN OBJECTPOOL_API TAUTOCONSOLEVARIABLE<BOOL> CVARENABLEOBJECTPOOL;

VOID UNETDRIVER::NOTIFYACTORDESTROYED( AACTOR* THISACTOR, BOOL ISSEAMLESSTRAVEL )
{
	// REMOVE THE ACTOR FROM THE PROPERTY TRACKER MAP
	REPCHANGEDPROPERTYTRACKERMAP.REMOVE(THISACTOR);

	CONST BOOL BISSERVER = ISSERVER();
	
	IF (BISSERVER)
	{
		FACTORDESTRUCTIONINFO* DESTRUCTIONINFO = NULLPTR;

		CONST BOOL BISACTORSTATIC = !GUIDCACHE->ISDYNAMICOBJECT( THISACTOR );
		CONST BOOL BACTORHASROLE = THISACTOR->GETREMOTEROLE() != ROLE_NONE;
		CONST BOOL BSHOULDCREATEDESTRUCTIONINFO = BISSERVER && BISACTORSTATIC && BACTORHASROLE && !ISSEAMLESSTRAVEL;

		IF (BSHOULDCREATEDESTRUCTIONINFO)
		{
			UE_LOG(LOGNET, VERYVERBOSE, TEXT("NOTIFYACTORDESTROYED %S - STARTUPACTOR"), *THISACTOR->GETPATHNAME() );
			DESTRUCTIONINFO = CREATEDESTRUCTIONINFO( THIS, THISACTOR, DESTRUCTIONINFO);
		}

		CONST FNETWORKOBJECTINFO* NETWORKOBJECTINFO = GETNETWORKOBJECTLIST().FIND( THISACTOR ).GET();

		FOR( INT32 I=CLIENTCONNECTIONS.NUM()-1; I>=0; I-- )
		{
			UNETCONNECTION* CONNECTION = CLIENTCONNECTIONS[I];
			IF( THISACTOR->BNETTEMPORARY )
				CONNECTION->SENTTEMPORARIES.REMOVE( THISACTOR );
			UACTORCHANNEL* CHANNEL = CONNECTION->FINDACTORCHANNELREF(THISACTOR);
			IF( CHANNEL )
			{
				CHECK(CHANNEL->OPENEDLOCALLY);
				CHANNEL->BCLEARRECENTACTORREFS = FALSE;
				CHANNEL->CLOSE(ECHANNELCLOSEREASON::DESTROYED);
			}
			ELSE
			{
				CONST BOOL BDORMANTORRECENTLYDORMANT = NETWORKOBJECTINFO && (NETWORKOBJECTINFO->DORMANTCONNECTIONS.CONTAINS(CONNECTION) || NETWORKOBJECTINFO->RECENTLYDORMANTCONNECTIONS.CONTAINS(CONNECTION));

				IF (BSHOULDCREATEDESTRUCTIONINFO || BDORMANTORRECENTLYDORMANT)
				{
					// MAKE A NEW DESTRUCTION INFO IF NECESSARY. IT IS NECESSARY IF THE ACTOR IS DORMANT OR RECENTLY DORMANT BECAUSE
					// EVEN THOUGH THE CLIENT KNEW ABOUT THE ACTOR AT SOME POINT, IT DOESN'T HAVE A CHANNEL TO HANDLE DESTRUCTION.
					DESTRUCTIONINFO = CREATEDESTRUCTIONINFO(THIS, THISACTOR, DESTRUCTIONINFO);
					IF (DESTRUCTIONINFO)
					{
						CONNECTION->ADDDESTRUCTIONINFO(DESTRUCTIONINFO);
					}
				}
			}

			CONNECTION->NOTIFYACTORDESTROYED(THISACTOR);
		}
		
		// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL START
		// REMOVE OBJECT-POOLED ACTOR FROM GLOBAL CACHE ON SERVER SIDE (BY LXH)
		//
		// THE OBJECT-POOLED ACTOR AND ITS REPLICATED COMPONENTS MUST BE REMOVED FROM 'OBJECTLOOKUP' AND 'NETGUIDLOOKUP' IN GUIDCACHE
		// TO ENSURE THE EXACT OBJECT POOL FLOW FOR ACTORS(SPAWNACTOR AND DESTROYACTOR).
		BOOL BSHOULDHANDLEFOROBJECTPOOL = FALSE;
		IF (ISVALID(THISACTOR) && ISVALID(THISACTOR->GETCLASS()) && THISACTOR->IMPLEMENTS<UREUSABLE>())
		{
			IF (CONST IREUSABLE* DEFAULTREUSABLEACTOR = CAST<IREUSABLE>(THISACTOR->GETCLASS()->GETDEFAULTOBJECT()))
			{
				BSHOULDHANDLEFOROBJECTPOOL = DEFAULTREUSABLEACTOR->SHOULDUSEOBJECTPOOL();
			}
		}
		
		IF (CVARENABLEOBJECTPOOL.GETVALUEONGAMETHREAD() && BSHOULDHANDLEFOROBJECTPOOL && GUIDCACHE.ISVALID())
		{
			CONST FNETWORKGUID* ACTORNETGUID = GUIDCACHE->NETGUIDLOOKUP.FIND(THISACTOR);
			IF (ACTORNETGUID)
			{
				GUIDCACHE->OBJECTLOOKUP.REMOVE(*ACTORNETGUID);
				GUIDCACHE->NETGUIDLOOKUP.REMOVE(THISACTOR);
			}

			CONST TARRAY<UACTORCOMPONENT*>& REPCOMPS = THISACTOR->GETREPLICATEDCOMPONENTS();
			FOR (UACTORCOMPONENT* REPCOMP : REPCOMPS)
			{
				IF (!ISVALID(REPCOMP)) CONTINUE;

				CONST FNETWORKGUID* REPCOMPNETGUID = GUIDCACHE->NETGUIDLOOKUP.FIND(REPCOMP);
				IF (REPCOMPNETGUID)
				{
					GUIDCACHE->OBJECTLOOKUP.REMOVE(*REPCOMPNETGUID);
					GUIDCACHE->NETGUIDLOOKUP.REMOVE(REPCOMP);
				}
			}
		}
		// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OBJECTPOOL END
	}

	IF (SERVERCONNECTION)
	{
		SERVERCONNECTION->NOTIFYACTORDESTROYED(THISACTOR);
	}

	// REMOVE THIS ACTOR FROM THE NETWORK OBJECT LIST
	REMOVENETWORKACTOR( THISACTOR );
}